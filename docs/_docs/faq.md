---
title: Frequently Asked Questions
category: General
order: 1
toc: true
---

### Design

#### Will React4j work on future versions of GWT?

React4j was designed from the ground up to be as forward compatible as possible with future
versions of GWT. Google is currently working on J2CL (Java 2 Closure Compiler) which is a
modern take on a java-to-javascript transpiler that emits Closure Compiler annotated javascript
as output. This promises a modern take on the story with an even more advanced optimizing
compiler working in the background.

React4j aims to target J2CL as early as possible while maintaining compatibility with GWT2.x for
as long as possible and likely targeting GWT 3.x into the future. The library does this by using
jsinterop and [elemental2](https://github.com/google/elemental2) to interact with the browser.

#### Where is the equivalent of React's stateless function components?

The project originally supported stateless functional components defined by an interface that had
a single render method. You could define the rendering of the method using a simple lambda method
that accepted a prop. This resulted in code that looked like:

```java
class MyComponent {
  @JsType(isNative = true, namespace = JsPackage.GLOBAL, name = "Object")
  static class Props extends BaseProps {
    int param;
  }

  @ReactComponent
  public static final StatelessComponent<Props> COMPONENT = (props) -> {
    return span(new HtmlProps().className("myclass"), String.valueOf( props.param ));
  };
}
```

Contrast this with the code that used normal components:

```java
@ReactComponent
class MyComponent extends Component<MyComponent.Props, BaseState> {
  @JsType(isNative = true, namespace = JsPackage.GLOBAL, name = "Object")
  static class Props extends BaseProps {
    int param;
  }

  public ReactElement<?, ?> render() {
    return span(new HtmlProps().className("myclass"), String.valueOf( props.param ));
  };
}
```

In java, the StatelessComponent approach seemed to offer few advantages as the two approaches were
roughly equal in the amount of ceremony required and identical from a performance standpoint. However the
StatelessComponent approach required more work if you needed to refactor the components later to add state,
or use the lifecycle callback methods.

So we removed StatelessComponent and simplified our application, the library and supporting tools. (The
annotation processor is significantly simpler as a result of this change.)

The react team has promised that at some point in the future, stateless functional components will have a
better performance profile due to lower memory usage and low-level optimization opportunities within
the react runtime. When this eventuates, it will be reasonably easy for React4j to take advantage of these
enhancements with no changes to the way components are written. The annotation processor already analyzes
the component to determine if the component uses state or any lifecycle methods are declared. If neither
of these conditions are true, React4j could transparently expose the component as a stateless functional
component and take advantage of the potential performance enhancements.

Actually it turns out that functional components should be slightly faster in React 16 as there's no
instance created to wrap them unlike in React 15. However this seems to be obscured by the slight overhead
of React4j but when/if the performance becomes more discernible, expect React4j to begin supporting stateless
functional components. 

#### Why is there both NativeComponent and Component classes?

The project initially required that React4j components all extend the equivalent of the `NativeComponent`
and thus all React4j had to be exported as javascript objects using the `@JsType(isNative = false)` annotation.
This model required that the developer was very aware of the constraints of developing classes that would be
exported as javascript. This often resulted in lots of code being annotated with either `@JsIgnore` or
`@SuppressWarnings("unusable-by-js")` to avoid warnings being generated by the GWT compiler. The developer
experience was less than optimal.

Building a parallel component hierarchy allowed us to remove the additional boilerplate and constraints required
to export a native object to javascript. It also made it possible to validate the way that the code inter-operates
with the native react runtime.

#### Why does React4j manually export types to Javascript?

GWT has `@JsType(isNative = false)` and yet the framework does not use it. The main reason is that this
is not a use case the J2CL/GWT compiler team want to support. `@JsType(isNative = false)` is intended to
be used to export classes for consumption by other javascript projects and requires that the consumers of
the library pass command line arguments to the compiler to control which parts of the framework is exported
to native javascript. React4j needs to export components in a particular shape so that the native javascript
library knows how to use the components. Turning off exports or excluding the wrong elements would result in
a broken library. As the J2CL/GWT team have taken a philosophical stance against controlling the
export of code inside `.gwt.xml`, there is a strong possibility that users of React4j could end up with broken
applications through incorrect build configuration.

To avoid this scenario impacting users of React4j, the library manually exports the components to native code.
Users of the library are free to use `@JsType(isNative = false)` and control it through the normal means but
this should not impact the correctness of the React4j <=> react integration. The amount of code that is manually
exported to Javascript has been minimized and is mostly restricted to the equivalent of static class properties
in ES6.
