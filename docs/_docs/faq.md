---
title: Frequently Asked Questions
category: General
order: 1
toc: true
---

---

### Design

#### Where is the equivalent of React's stateless function components?

The project originally supported stateless functional components defined by an interface that had
a single render method. You could define the rendering of the method using a simple lambda method
that accepted a prop. This resulted in code that looked like: 

```java
class MyComponent {
  @JsType(isNative = true, namespace = JsPackage.GLOBAL, name = "Object")
  static class Props extends BaseProps {
    int param;
  }

  @ReactComponent
  public static final StatelessComponent<Props> COMPONENT = (props) -> {
    return span(new HtmlProps().className("myclass"), String.valueOf( props.param ));
  };
}
```

Contrast this with the code that used normal components:

```java
@ReactComponent
class MyComponent extends Component<MyComponent.Props, BaseState> {
  @JsType(isNative = true, namespace = JsPackage.GLOBAL, name = "Object")
  static class Props extends BaseProps {
    int param;
  }

  public ReactElement<?, ?> render() {
    return span(new HtmlProps().className("myclass"), String.valueOf( props.param ));
  };
}
```

In java, the StatelessComponent approach seemed to offer few advantages as the two approaches were
roughly equal in the amount of ceremony required and identical from a performance standpoint. However the
StatelessComponent approach required more work if you needed to refactor the components later to add state,
or use the lifecycle callback methods.

So we removed StatelessComponent and simplified our application, the library and supporting tools. (The
annotation processor is significantly simpler as a result of this change.)

#### Why is there both NativeComponent and Component classes?

The project initially required that React4j components all extend the equivalent of the <tt>NativeComponent</tt>
and thus all React4j had to be exported as javascript objects using the <tt>@JsType</tt> annotation. This model
required that the developer was very aware of the constraints of developing classes that would be exported as 
javascript. This often resulted in lots of code being annotated with either <tt>@JsIgnore</tt> or
<tt>@SuppressWarnings("unusable-by-js")</tt> to avoid warnings being generated by the GWT compiler. The developer
experience was less than optimal.

Building a parallel component hierarchy allowed us to remove the additional boilerplate and constraints required
to export a native object to javascript. It also made it possible to validate the way that the code interoperates
with the native react runtime.
