---
title: Frequently Asked Questions
category: General
order: 1
toc: true
---

### Design

#### Will React4j work on later versions of GWT?

React4j was designed from the ground up to be as forward compatible as possible with later
versions of GWT. Google is currently working on J2CL (Java 2 Closure Compiler) which is a
modern take on a java-to-javascript transpiler that targets a Closure Compiler annotated
javascript output. This promises a modern take on the story with a even more advanced optimizing
compiler working in the background.

React4j aims to target J2CL this as early as possible, maintaining compatibility with GWT2.x for
as long as possible and likely targeting GWT 3.x into the future. The library does this by using
jsinterop everywhere and [elemental2](https://github.com/google/elemental2) to interact with the
browser. 

#### Where is the equivalent of React's stateless function components?

The project originally supported stateless functional components defined by an interface that had
a single render method. You could define the rendering of the method using a simple lambda method
that accepted a prop. This resulted in code that looked like:

```java
class MyComponent {
  @JsType(isNative = true, namespace = JsPackage.GLOBAL, name = "Object")
  static class Props extends BaseProps {
    int param;
  }

  @ReactComponent
  public static final StatelessComponent<Props> COMPONENT = (props) -> {
    return span(new HtmlProps().className("myclass"), String.valueOf( props.param ));
  };
}
```

Contrast this with the code that used normal components:

```java
@ReactComponent
class MyComponent extends Component<MyComponent.Props, BaseState> {
  @JsType(isNative = true, namespace = JsPackage.GLOBAL, name = "Object")
  static class Props extends BaseProps {
    int param;
  }

  public ReactElement<?, ?> render() {
    return span(new HtmlProps().className("myclass"), String.valueOf( props.param ));
  };
}
```

In java, the StatelessComponent approach seemed to offer few advantages as the two approaches were
roughly equal in the amount of ceremony required and identical from a performance standpoint. However the
StatelessComponent approach required more work if you needed to refactor the components later to add state,
or use the lifecycle callback methods.

So we removed StatelessComponent and simplified our application, the library and supporting tools. (The
annotation processor is significantly simpler as a result of this change.)

#### Why is there both NativeComponent and Component classes?

The project initially required that React4j components all extend the equivalent of the `NativeComponent`
and thus all React4j had to be exported as javascript objects using the `@JsType(isNative = false)` annotation.
This model required that the developer was very aware of the constraints of developing classes that would be
exported as javascript. This often resulted in lots of code being annotated with either `@JsIgnore` or
`@SuppressWarnings("unusable-by-js")` to avoid warnings being generated by the GWT compiler. The developer
experience was less than optimal.

Building a parallel component hierarchy allowed us to remove the additional boilerplate and constraints required
to export a native object to javascript. It also made it possible to validate the way that the code inter-operates
with the native react runtime.

#### Why does React4j manually export types to Javascript?

GWT has `@JsType(isNative = false)` and yet the framework does not use it. The main reason is that this
is not a use case the J2CL/GWT compiler team want to support. `@JsType(isNative = false)` is intended to
be used to export classes for consumption by other javascript projects and requires that the consumers of
the library pass command line arguments to the compiler to control which parts of the framework is exported
to native javascript. React4j needs to export components in a particular shape so that the native javascript
library knows how to use the components. Turning off exports or excluding the wrong elements would result in
a broken library. As the J2CL/GWT team have taken a philosophical stance against controlling the
export of code inside `.gwt.xml`, there is a strong possibility that users of React4j could end up with broken
applications through incorrect build configuration.

To avoid this scenario impacting users of React4j, the library manually exports the components to native code.
Users of the library are free to use `@JsType(isNative = false)` and control it through the normal means but
this should not impact the correctness of the React4j <=> react integration.
